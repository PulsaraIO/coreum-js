// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v3.21.12
// source: coreum-protos/dex/order.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "cosmjs-types/binary";
import { Coin } from "cosmjs-types/cosmos/base/v1beta1/coin";
import { Timestamp } from "cosmjs-types/google/protobuf/timestamp";

export const protobufPackage = "coreum.dex.v1";

/** Side is order side. */
export enum Side {
  /** SIDE_UNSPECIFIED - SIDE_UNSPECIFIED reserves the default value, to protect against unexpected settings. */
  SIDE_UNSPECIFIED = 0,
  /** SIDE_BUY - SIDE_BUY means that the order is to buy base_denom quantity with the price. */
  SIDE_BUY = 1,
  /** SIDE_SELL - SIDE_SELL means that the order is to sell base_denom quantity with the price. */
  SIDE_SELL = 2,
  UNRECOGNIZED = -1,
}

export function sideFromJSON(object: any): Side {
  switch (object) {
    case 0:
    case "SIDE_UNSPECIFIED":
      return Side.SIDE_UNSPECIFIED;
    case 1:
    case "SIDE_BUY":
      return Side.SIDE_BUY;
    case 2:
    case "SIDE_SELL":
      return Side.SIDE_SELL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Side.UNRECOGNIZED;
  }
}

export function sideToJSON(object: Side): string {
  switch (object) {
    case Side.SIDE_UNSPECIFIED:
      return "SIDE_UNSPECIFIED";
    case Side.SIDE_BUY:
      return "SIDE_BUY";
    case Side.SIDE_SELL:
      return "SIDE_SELL";
    case Side.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Type is order type. */
export enum OrderType {
  /** ORDER_TYPE_UNSPECIFIED - order_type_unspecified reserves the default value, to protect against unexpected settings. */
  ORDER_TYPE_UNSPECIFIED = 0,
  /** ORDER_TYPE_LIMIT - order_type_limit means that the order is limit order. */
  ORDER_TYPE_LIMIT = 1,
  /** ORDER_TYPE_MARKET - limit order_type_market that the order is market order. */
  ORDER_TYPE_MARKET = 2,
  UNRECOGNIZED = -1,
}

export function orderTypeFromJSON(object: any): OrderType {
  switch (object) {
    case 0:
    case "ORDER_TYPE_UNSPECIFIED":
      return OrderType.ORDER_TYPE_UNSPECIFIED;
    case 1:
    case "ORDER_TYPE_LIMIT":
      return OrderType.ORDER_TYPE_LIMIT;
    case 2:
    case "ORDER_TYPE_MARKET":
      return OrderType.ORDER_TYPE_MARKET;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OrderType.UNRECOGNIZED;
  }
}

export function orderTypeToJSON(object: OrderType): string {
  switch (object) {
    case OrderType.ORDER_TYPE_UNSPECIFIED:
      return "ORDER_TYPE_UNSPECIFIED";
    case OrderType.ORDER_TYPE_LIMIT:
      return "ORDER_TYPE_LIMIT";
    case OrderType.ORDER_TYPE_MARKET:
      return "ORDER_TYPE_MARKET";
    case OrderType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** TimeInForce is order time in force. */
export enum TimeInForce {
  /** TIME_IN_FORCE_UNSPECIFIED - time_in_force_unspecified reserves the default value, to protect against unexpected settings. */
  TIME_IN_FORCE_UNSPECIFIED = 0,
  /** TIME_IN_FORCE_GTC - time_in_force_gtc means that the order remains active until it is fully executed or manually canceled. */
  TIME_IN_FORCE_GTC = 1,
  /**
   * TIME_IN_FORCE_IOC - time_in_force_ioc  means that order must be executed immediately, either in full or partially. Any portion of the
   *  order that cannot be filled immediately is canceled.
   */
  TIME_IN_FORCE_IOC = 2,
  /** TIME_IN_FORCE_FOK - time_in_force_fok means that order must be fully executed or canceled. */
  TIME_IN_FORCE_FOK = 3,
  UNRECOGNIZED = -1,
}

export function timeInForceFromJSON(object: any): TimeInForce {
  switch (object) {
    case 0:
    case "TIME_IN_FORCE_UNSPECIFIED":
      return TimeInForce.TIME_IN_FORCE_UNSPECIFIED;
    case 1:
    case "TIME_IN_FORCE_GTC":
      return TimeInForce.TIME_IN_FORCE_GTC;
    case 2:
    case "TIME_IN_FORCE_IOC":
      return TimeInForce.TIME_IN_FORCE_IOC;
    case 3:
    case "TIME_IN_FORCE_FOK":
      return TimeInForce.TIME_IN_FORCE_FOK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TimeInForce.UNRECOGNIZED;
  }
}

export function timeInForceToJSON(object: TimeInForce): string {
  switch (object) {
    case TimeInForce.TIME_IN_FORCE_UNSPECIFIED:
      return "TIME_IN_FORCE_UNSPECIFIED";
    case TimeInForce.TIME_IN_FORCE_GTC:
      return "TIME_IN_FORCE_GTC";
    case TimeInForce.TIME_IN_FORCE_IOC:
      return "TIME_IN_FORCE_IOC";
    case TimeInForce.TIME_IN_FORCE_FOK:
      return "TIME_IN_FORCE_FOK";
    case TimeInForce.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** GoodTil is a good til order settings. */
export interface GoodTil {
  /** good_til_block_height means that order remains active until a specific blockchain block height is reached. */
  goodTilBlockHeight: number;
  /** good_til_block_time means that order remains active until a specific blockchain block time is reached. */
  goodTilBlockTime: Date | undefined;
}

/** CancelGoodTil is a cancel good til message for the delay router. */
export interface CancelGoodTil {
  /** creator is order creator address. */
  creator: string;
  /** order_sequence is order sequence. */
  orderSequence: number;
}

/**
 * Order represents a DEX order, encapsulating both limit and market orders. It contains comprehensive information about
 * the order's state.
 */
export interface Order {
  /** creator is order creator address. */
  creator: string;
  /** type is order type. */
  type: OrderType;
  /** id is unique order ID. */
  id: string;
  /** sequence is unique order sequence generated at the time of the order placement. */
  sequence: number;
  /** base_denom is base order denom. */
  baseDenom: string;
  /** quote_denom is quote order denom */
  quoteDenom: string;
  /** price is value of one unit of the base_denom expressed in terms of the quote_denom. */
  price: string;
  /** quantity is amount of the base base_denom being traded. */
  quantity: string;
  /** side is order side. */
  side: Side;
  /** remaining_base_quantity - is remaining quantity of base denom which user wants to sell or buy. */
  remainingBaseQuantity: string;
  /** remaining_spendable_balance - is balance up to which user wants to spend to execute the order. */
  remainingSpendableBalance: string;
  /** good_til is order good til */
  goodTil: GoodTil | undefined;
  /** time_in_force is order time in force */
  timeInForce: TimeInForce;
  /** reserve is the reserve required to save the order in the order book */
  reserve: Coin | undefined;
}

/** OrderData represents the order information for the store missing in the order book record. */
export interface OrderData {
  /** order ID provided by the creator. */
  orderId: string;
  /** order_book_id is order book ID. */
  orderBookId: number;
  /** price is value of one unit of the base_denom expressed in terms of the quote_denom. */
  price: string;
  /** quantity is amount of the base base_denom being traded. */
  quantity: string;
  /** side is order side. */
  side: Side;
  /** good_til is order good til */
  goodTil: GoodTil | undefined;
  /** reserve is the reserve required to save the order in the order book */
  reserve: Coin | undefined;
}

/** OrderBookData is a order book data used by order for the store. */
export interface OrderBookData {
  /** base_denom is base order book denom. */
  baseDenom: string;
  /** quote_denom is quote order book denom */
  quoteDenom: string;
}

/** OrderBookRecord is a single order book record, it combines both key and value from the store. */
export interface OrderBookRecord {
  /** order_book_id is order book ID. */
  orderBookId: number;
  /** side is order side. */
  side: Side;
  /** price is order book record price. */
  price: string;
  /** order_sequence is order sequence. */
  orderSequence: number;
  /** order ID provided by the creator. */
  orderId: string;
  /** account_number is account number which corresponds the order creator. */
  accountNumber: number;
  /** remaining_base_quantity - is remaining quantity of base denom which user wants to sell or buy. */
  remainingBaseQuantity: string;
  /** remaining_spendable_balance - is balance up to which user wants to spend to execute the order. */
  remainingSpendableBalance: string;
}

/** OrderBookRecordData is a single order book record used for the store. */
export interface OrderBookRecordData {
  /** order ID provided by the creator. */
  orderId: string;
  /** account_number is account number which corresponds the order creator. */
  accountNumber: number;
  /** remaining_base_quantity - is remaining quantity of base denom which user wants to sell or buy. */
  remainingBaseQuantity: string;
  /** remaining_spendable_balance - is balance up to which user wants to spend to execute the order. */
  remainingSpendableBalance: string;
}

function createBaseGoodTil(): GoodTil {
  return { goodTilBlockHeight: 0, goodTilBlockTime: undefined };
}

export const GoodTil: MessageFns<GoodTil> = {
  encode(
    message: GoodTil,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.goodTilBlockHeight !== 0) {
      writer.uint32(8).uint64(message.goodTilBlockHeight);
    }
    if (message.goodTilBlockTime !== undefined) {
      Timestamp.encode(
        toTimestamp(message.goodTilBlockTime),
        writer.uint32(18).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GoodTil {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoodTil();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.goodTilBlockHeight = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.goodTilBlockTime = fromTimestamp(
            Timestamp.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GoodTil {
    return {
      goodTilBlockHeight: isSet(object.goodTilBlockHeight)
        ? globalThis.Number(object.goodTilBlockHeight)
        : 0,
      goodTilBlockTime: isSet(object.goodTilBlockTime)
        ? fromJsonTimestamp(object.goodTilBlockTime)
        : undefined,
    };
  },

  toJSON(message: GoodTil): unknown {
    const obj: any = {};
    if (message.goodTilBlockHeight !== 0) {
      obj.goodTilBlockHeight = Math.round(message.goodTilBlockHeight);
    }
    if (message.goodTilBlockTime !== undefined) {
      obj.goodTilBlockTime = message.goodTilBlockTime.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GoodTil>, I>>(base?: I): GoodTil {
    return GoodTil.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GoodTil>, I>>(object: I): GoodTil {
    const message = createBaseGoodTil();
    message.goodTilBlockHeight = object.goodTilBlockHeight ?? 0;
    message.goodTilBlockTime = object.goodTilBlockTime ?? undefined;
    return message;
  },
};

function createBaseCancelGoodTil(): CancelGoodTil {
  return { creator: "", orderSequence: 0 };
}

export const CancelGoodTil: MessageFns<CancelGoodTil> = {
  encode(
    message: CancelGoodTil,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.orderSequence !== 0) {
      writer.uint32(16).uint64(message.orderSequence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelGoodTil {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelGoodTil();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.orderSequence = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelGoodTil {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      orderSequence: isSet(object.orderSequence)
        ? globalThis.Number(object.orderSequence)
        : 0,
    };
  },

  toJSON(message: CancelGoodTil): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.orderSequence !== 0) {
      obj.orderSequence = Math.round(message.orderSequence);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelGoodTil>, I>>(
    base?: I
  ): CancelGoodTil {
    return CancelGoodTil.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelGoodTil>, I>>(
    object: I
  ): CancelGoodTil {
    const message = createBaseCancelGoodTil();
    message.creator = object.creator ?? "";
    message.orderSequence = object.orderSequence ?? 0;
    return message;
  },
};

function createBaseOrder(): Order {
  return {
    creator: "",
    type: 0,
    id: "",
    sequence: 0,
    baseDenom: "",
    quoteDenom: "",
    price: "",
    quantity: "",
    side: 0,
    remainingBaseQuantity: "",
    remainingSpendableBalance: "",
    goodTil: undefined,
    timeInForce: 0,
    reserve: undefined,
  };
}

export const Order: MessageFns<Order> = {
  encode(
    message: Order,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.id !== "") {
      writer.uint32(26).string(message.id);
    }
    if (message.sequence !== 0) {
      writer.uint32(32).uint64(message.sequence);
    }
    if (message.baseDenom !== "") {
      writer.uint32(42).string(message.baseDenom);
    }
    if (message.quoteDenom !== "") {
      writer.uint32(50).string(message.quoteDenom);
    }
    if (message.price !== "") {
      writer.uint32(58).string(message.price);
    }
    if (message.quantity !== "") {
      writer.uint32(66).string(message.quantity);
    }
    if (message.side !== 0) {
      writer.uint32(72).int32(message.side);
    }
    if (message.remainingBaseQuantity !== "") {
      writer.uint32(82).string(message.remainingBaseQuantity);
    }
    if (message.remainingSpendableBalance !== "") {
      writer.uint32(90).string(message.remainingSpendableBalance);
    }
    if (message.goodTil !== undefined) {
      GoodTil.encode(message.goodTil, writer.uint32(98).fork()).ldelim();
    }
    if (message.timeInForce !== 0) {
      writer.uint32(104).int32(message.timeInForce);
    }
    if (message.reserve !== undefined) {
      Coin.encode(message.reserve, writer.uint32(114).fork()).ldelim();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Order {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.sequence = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.baseDenom = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.quoteDenom = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.price = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.quantity = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.side = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.remainingBaseQuantity = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.remainingSpendableBalance = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.goodTil = GoodTil.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.timeInForce = reader.int32() as any;
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.reserve = Coin.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Order {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      type: isSet(object.type) ? orderTypeFromJSON(object.type) : 0,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      sequence: isSet(object.sequence) ? globalThis.Number(object.sequence) : 0,
      baseDenom: isSet(object.baseDenom)
        ? globalThis.String(object.baseDenom)
        : "",
      quoteDenom: isSet(object.quoteDenom)
        ? globalThis.String(object.quoteDenom)
        : "",
      price: isSet(object.price) ? globalThis.String(object.price) : "",
      quantity: isSet(object.quantity)
        ? globalThis.String(object.quantity)
        : "",
      side: isSet(object.side) ? sideFromJSON(object.side) : 0,
      remainingBaseQuantity: isSet(object.remainingBaseQuantity)
        ? globalThis.String(object.remainingBaseQuantity)
        : "",
      remainingSpendableBalance: isSet(object.remainingSpendableBalance)
        ? globalThis.String(object.remainingSpendableBalance)
        : "",
      goodTil: isSet(object.goodTil)
        ? GoodTil.fromJSON(object.goodTil)
        : undefined,
      timeInForce: isSet(object.timeInForce)
        ? timeInForceFromJSON(object.timeInForce)
        : 0,
      reserve: isSet(object.reserve)
        ? Coin.fromJSON(object.reserve)
        : undefined,
    };
  },

  toJSON(message: Order): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.type !== 0) {
      obj.type = orderTypeToJSON(message.type);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.sequence !== 0) {
      obj.sequence = Math.round(message.sequence);
    }
    if (message.baseDenom !== "") {
      obj.baseDenom = message.baseDenom;
    }
    if (message.quoteDenom !== "") {
      obj.quoteDenom = message.quoteDenom;
    }
    if (message.price !== "") {
      obj.price = message.price;
    }
    if (message.quantity !== "") {
      obj.quantity = message.quantity;
    }
    if (message.side !== 0) {
      obj.side = sideToJSON(message.side);
    }
    if (message.remainingBaseQuantity !== "") {
      obj.remainingBaseQuantity = message.remainingBaseQuantity;
    }
    if (message.remainingSpendableBalance !== "") {
      obj.remainingSpendableBalance = message.remainingSpendableBalance;
    }
    if (message.goodTil !== undefined) {
      obj.goodTil = GoodTil.toJSON(message.goodTil);
    }
    if (message.timeInForce !== 0) {
      obj.timeInForce = timeInForceToJSON(message.timeInForce);
    }
    if (message.reserve !== undefined) {
      obj.reserve = Coin.toJSON(message.reserve);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Order>, I>>(base?: I): Order {
    return Order.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Order>, I>>(object: I): Order {
    const message = createBaseOrder();
    message.creator = object.creator ?? "";
    message.type = object.type ?? 0;
    message.id = object.id ?? "";
    message.sequence = object.sequence ?? 0;
    message.baseDenom = object.baseDenom ?? "";
    message.quoteDenom = object.quoteDenom ?? "";
    message.price = object.price ?? "";
    message.quantity = object.quantity ?? "";
    message.side = object.side ?? 0;
    message.remainingBaseQuantity = object.remainingBaseQuantity ?? "";
    message.remainingSpendableBalance = object.remainingSpendableBalance ?? "";
    message.goodTil =
      object.goodTil !== undefined && object.goodTil !== null
        ? GoodTil.fromPartial(object.goodTil)
        : undefined;
    message.timeInForce = object.timeInForce ?? 0;
    message.reserve =
      object.reserve !== undefined && object.reserve !== null
        ? Coin.fromPartial(object.reserve)
        : undefined;
    return message;
  },
};

function createBaseOrderData(): OrderData {
  return {
    orderId: "",
    orderBookId: 0,
    price: "",
    quantity: "",
    side: 0,
    goodTil: undefined,
    reserve: undefined,
  };
}

export const OrderData: MessageFns<OrderData> = {
  encode(
    message: OrderData,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.orderBookId !== 0) {
      writer.uint32(16).uint32(message.orderBookId);
    }
    if (message.price !== "") {
      writer.uint32(26).string(message.price);
    }
    if (message.quantity !== "") {
      writer.uint32(34).string(message.quantity);
    }
    if (message.side !== 0) {
      writer.uint32(40).int32(message.side);
    }
    if (message.goodTil !== undefined) {
      GoodTil.encode(message.goodTil, writer.uint32(50).fork()).ldelim();
    }
    if (message.reserve !== undefined) {
      Coin.encode(message.reserve, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderData {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.orderBookId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.price = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.quantity = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.side = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.goodTil = GoodTil.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.reserve = Coin.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderData {
    return {
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      orderBookId: isSet(object.orderBookId)
        ? globalThis.Number(object.orderBookId)
        : 0,
      price: isSet(object.price) ? globalThis.String(object.price) : "",
      quantity: isSet(object.quantity)
        ? globalThis.String(object.quantity)
        : "",
      side: isSet(object.side) ? sideFromJSON(object.side) : 0,
      goodTil: isSet(object.goodTil)
        ? GoodTil.fromJSON(object.goodTil)
        : undefined,
      reserve: isSet(object.reserve)
        ? Coin.fromJSON(object.reserve)
        : undefined,
    };
  },

  toJSON(message: OrderData): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.orderBookId !== 0) {
      obj.orderBookId = Math.round(message.orderBookId);
    }
    if (message.price !== "") {
      obj.price = message.price;
    }
    if (message.quantity !== "") {
      obj.quantity = message.quantity;
    }
    if (message.side !== 0) {
      obj.side = sideToJSON(message.side);
    }
    if (message.goodTil !== undefined) {
      obj.goodTil = GoodTil.toJSON(message.goodTil);
    }
    if (message.reserve !== undefined) {
      obj.reserve = Coin.toJSON(message.reserve);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderData>, I>>(base?: I): OrderData {
    return OrderData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderData>, I>>(
    object: I
  ): OrderData {
    const message = createBaseOrderData();
    message.orderId = object.orderId ?? "";
    message.orderBookId = object.orderBookId ?? 0;
    message.price = object.price ?? "";
    message.quantity = object.quantity ?? "";
    message.side = object.side ?? 0;
    message.goodTil =
      object.goodTil !== undefined && object.goodTil !== null
        ? GoodTil.fromPartial(object.goodTil)
        : undefined;
    message.reserve =
      object.reserve !== undefined && object.reserve !== null
        ? Coin.fromPartial(object.reserve)
        : undefined;
    return message;
  },
};

function createBaseOrderBookData(): OrderBookData {
  return { baseDenom: "", quoteDenom: "" };
}

export const OrderBookData: MessageFns<OrderBookData> = {
  encode(
    message: OrderBookData,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.baseDenom !== "") {
      writer.uint32(10).string(message.baseDenom);
    }
    if (message.quoteDenom !== "") {
      writer.uint32(18).string(message.quoteDenom);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderBookData {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderBookData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseDenom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.quoteDenom = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderBookData {
    return {
      baseDenom: isSet(object.baseDenom)
        ? globalThis.String(object.baseDenom)
        : "",
      quoteDenom: isSet(object.quoteDenom)
        ? globalThis.String(object.quoteDenom)
        : "",
    };
  },

  toJSON(message: OrderBookData): unknown {
    const obj: any = {};
    if (message.baseDenom !== "") {
      obj.baseDenom = message.baseDenom;
    }
    if (message.quoteDenom !== "") {
      obj.quoteDenom = message.quoteDenom;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderBookData>, I>>(
    base?: I
  ): OrderBookData {
    return OrderBookData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderBookData>, I>>(
    object: I
  ): OrderBookData {
    const message = createBaseOrderBookData();
    message.baseDenom = object.baseDenom ?? "";
    message.quoteDenom = object.quoteDenom ?? "";
    return message;
  },
};

function createBaseOrderBookRecord(): OrderBookRecord {
  return {
    orderBookId: 0,
    side: 0,
    price: "",
    orderSequence: 0,
    orderId: "",
    accountNumber: 0,
    remainingBaseQuantity: "",
    remainingSpendableBalance: "",
  };
}

export const OrderBookRecord: MessageFns<OrderBookRecord> = {
  encode(
    message: OrderBookRecord,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.orderBookId !== 0) {
      writer.uint32(8).uint32(message.orderBookId);
    }
    if (message.side !== 0) {
      writer.uint32(16).int32(message.side);
    }
    if (message.price !== "") {
      writer.uint32(26).string(message.price);
    }
    if (message.orderSequence !== 0) {
      writer.uint32(32).uint64(message.orderSequence);
    }
    if (message.orderId !== "") {
      writer.uint32(42).string(message.orderId);
    }
    if (message.accountNumber !== 0) {
      writer.uint32(48).uint64(message.accountNumber);
    }
    if (message.remainingBaseQuantity !== "") {
      writer.uint32(58).string(message.remainingBaseQuantity);
    }
    if (message.remainingSpendableBalance !== "") {
      writer.uint32(66).string(message.remainingSpendableBalance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderBookRecord {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderBookRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.orderBookId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.side = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.price = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.orderSequence = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.accountNumber = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.remainingBaseQuantity = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.remainingSpendableBalance = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderBookRecord {
    return {
      orderBookId: isSet(object.orderBookId)
        ? globalThis.Number(object.orderBookId)
        : 0,
      side: isSet(object.side) ? sideFromJSON(object.side) : 0,
      price: isSet(object.price) ? globalThis.String(object.price) : "",
      orderSequence: isSet(object.orderSequence)
        ? globalThis.Number(object.orderSequence)
        : 0,
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      accountNumber: isSet(object.accountNumber)
        ? globalThis.Number(object.accountNumber)
        : 0,
      remainingBaseQuantity: isSet(object.remainingBaseQuantity)
        ? globalThis.String(object.remainingBaseQuantity)
        : "",
      remainingSpendableBalance: isSet(object.remainingSpendableBalance)
        ? globalThis.String(object.remainingSpendableBalance)
        : "",
    };
  },

  toJSON(message: OrderBookRecord): unknown {
    const obj: any = {};
    if (message.orderBookId !== 0) {
      obj.orderBookId = Math.round(message.orderBookId);
    }
    if (message.side !== 0) {
      obj.side = sideToJSON(message.side);
    }
    if (message.price !== "") {
      obj.price = message.price;
    }
    if (message.orderSequence !== 0) {
      obj.orderSequence = Math.round(message.orderSequence);
    }
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.accountNumber !== 0) {
      obj.accountNumber = Math.round(message.accountNumber);
    }
    if (message.remainingBaseQuantity !== "") {
      obj.remainingBaseQuantity = message.remainingBaseQuantity;
    }
    if (message.remainingSpendableBalance !== "") {
      obj.remainingSpendableBalance = message.remainingSpendableBalance;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderBookRecord>, I>>(
    base?: I
  ): OrderBookRecord {
    return OrderBookRecord.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderBookRecord>, I>>(
    object: I
  ): OrderBookRecord {
    const message = createBaseOrderBookRecord();
    message.orderBookId = object.orderBookId ?? 0;
    message.side = object.side ?? 0;
    message.price = object.price ?? "";
    message.orderSequence = object.orderSequence ?? 0;
    message.orderId = object.orderId ?? "";
    message.accountNumber = object.accountNumber ?? 0;
    message.remainingBaseQuantity = object.remainingBaseQuantity ?? "";
    message.remainingSpendableBalance = object.remainingSpendableBalance ?? "";
    return message;
  },
};

function createBaseOrderBookRecordData(): OrderBookRecordData {
  return {
    orderId: "",
    accountNumber: 0,
    remainingBaseQuantity: "",
    remainingSpendableBalance: "",
  };
}

export const OrderBookRecordData: MessageFns<OrderBookRecordData> = {
  encode(
    message: OrderBookRecordData,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.accountNumber !== 0) {
      writer.uint32(16).uint64(message.accountNumber);
    }
    if (message.remainingBaseQuantity !== "") {
      writer.uint32(26).string(message.remainingBaseQuantity);
    }
    if (message.remainingSpendableBalance !== "") {
      writer.uint32(34).string(message.remainingSpendableBalance);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): OrderBookRecordData {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderBookRecordData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.accountNumber = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.remainingBaseQuantity = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.remainingSpendableBalance = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderBookRecordData {
    return {
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      accountNumber: isSet(object.accountNumber)
        ? globalThis.Number(object.accountNumber)
        : 0,
      remainingBaseQuantity: isSet(object.remainingBaseQuantity)
        ? globalThis.String(object.remainingBaseQuantity)
        : "",
      remainingSpendableBalance: isSet(object.remainingSpendableBalance)
        ? globalThis.String(object.remainingSpendableBalance)
        : "",
    };
  },

  toJSON(message: OrderBookRecordData): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.accountNumber !== 0) {
      obj.accountNumber = Math.round(message.accountNumber);
    }
    if (message.remainingBaseQuantity !== "") {
      obj.remainingBaseQuantity = message.remainingBaseQuantity;
    }
    if (message.remainingSpendableBalance !== "") {
      obj.remainingSpendableBalance = message.remainingSpendableBalance;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderBookRecordData>, I>>(
    base?: I
  ): OrderBookRecordData {
    return OrderBookRecordData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderBookRecordData>, I>>(
    object: I
  ): OrderBookRecordData {
    const message = createBaseOrderBookRecordData();
    message.orderId = object.orderId ?? "";
    message.accountNumber = object.accountNumber ?? 0;
    message.remainingBaseQuantity = object.remainingBaseQuantity ?? "";
    message.remainingSpendableBalance = object.remainingSpendableBalance ?? "";
    return message;
  },
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
  ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U>
  ? ReadonlyArray<DeepPartial<U>>
  : T extends {}
  ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds: BigInt(seconds), nanos };
}

function fromTimestamp(t: Timestamp): Date {
  const seconds = BigInt(t.seconds || 0);
  const nanos = BigInt(t.nanos || 0);

  const millis = seconds * BigInt(1000) + nanos / BigInt(1_000_000);
  return new Date(Number(millis));
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
