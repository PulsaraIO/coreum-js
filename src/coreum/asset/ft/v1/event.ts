// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v3.21.12
// source: coreum-protos/ft/event.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { DEXSettings, Feature, featureFromJSON, featureToJSON } from "./token";

export const protobufPackage = "coreum.asset.ft.v1";

/** EventIssued is emitted on MsgIssue. */
export interface EventIssued {
  denom: string;
  issuer: string;
  symbol: string;
  subunit: string;
  precision: number;
  initialAmount: string;
  description: string;
  features: Feature[];
  burnRate: string;
  sendCommissionRate: string;
  uri: string;
  uriHash: string;
  admin: string;
  dexSettings: DEXSettings | undefined;
}

export interface EventFrozenAmountChanged {
  account: string;
  denom: string;
  previousAmount: string;
  currentAmount: string;
}

export interface EventAmountClawedBack {
  account: string;
  denom: string;
  amount: string;
}

export interface EventWhitelistedAmountChanged {
  account: string;
  denom: string;
  previousAmount: string;
  currentAmount: string;
}

export interface EventDEXLockedAmountChanged {
  account: string;
  denom: string;
  previousAmount: string;
  currentAmount: string;
}

export interface EventDEXExpectedToReceiveAmountChanged {
  account: string;
  denom: string;
  previousAmount: string;
  currentAmount: string;
}

export interface EventAdminTransferred {
  denom: string;
  previousAdmin: string;
  currentAdmin: string;
}

export interface EventAdminCleared {
  denom: string;
  previousAdmin: string;
}

export interface EventDEXSettingsChanged {
  previousSettings: DEXSettings | undefined;
  newSettings: DEXSettings | undefined;
}

function createBaseEventIssued(): EventIssued {
  return {
    denom: "",
    issuer: "",
    symbol: "",
    subunit: "",
    precision: 0,
    initialAmount: "",
    description: "",
    features: [],
    burnRate: "",
    sendCommissionRate: "",
    uri: "",
    uriHash: "",
    admin: "",
    dexSettings: undefined,
  };
}

export const EventIssued: MessageFns<EventIssued> = {
  encode(
    message: EventIssued,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.issuer !== "") {
      writer.uint32(18).string(message.issuer);
    }
    if (message.symbol !== "") {
      writer.uint32(26).string(message.symbol);
    }
    if (message.subunit !== "") {
      writer.uint32(34).string(message.subunit);
    }
    if (message.precision !== 0) {
      writer.uint32(40).uint32(message.precision);
    }
    if (message.initialAmount !== "") {
      writer.uint32(50).string(message.initialAmount);
    }
    if (message.description !== "") {
      writer.uint32(58).string(message.description);
    }
    writer.uint32(66).fork();
    for (const v of message.features) {
      writer.int32(v);
    }
    writer.join();
    if (message.burnRate !== "") {
      writer.uint32(74).string(message.burnRate);
    }
    if (message.sendCommissionRate !== "") {
      writer.uint32(82).string(message.sendCommissionRate);
    }
    if (message.uri !== "") {
      writer.uint32(90).string(message.uri);
    }
    if (message.uriHash !== "") {
      writer.uint32(98).string(message.uriHash);
    }
    if (message.admin !== "") {
      writer.uint32(106).string(message.admin);
    }
    if (message.dexSettings !== undefined) {
      DEXSettings.encode(message.dexSettings, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventIssued {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventIssued();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.issuer = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.subunit = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.precision = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.initialAmount = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 8: {
          if (tag === 64) {
            message.features.push(reader.int32() as any);

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.features.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.burnRate = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.sendCommissionRate = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.uriHash = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.admin = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.dexSettings = DEXSettings.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventIssued {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      issuer: isSet(object.issuer) ? globalThis.String(object.issuer) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      subunit: isSet(object.subunit) ? globalThis.String(object.subunit) : "",
      precision: isSet(object.precision)
        ? globalThis.Number(object.precision)
        : 0,
      initialAmount: isSet(object.initialAmount)
        ? globalThis.String(object.initialAmount)
        : "",
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : "",
      features: globalThis.Array.isArray(object?.features)
        ? object.features.map((e: any) => featureFromJSON(e))
        : [],
      burnRate: isSet(object.burnRate)
        ? globalThis.String(object.burnRate)
        : "",
      sendCommissionRate: isSet(object.sendCommissionRate)
        ? globalThis.String(object.sendCommissionRate)
        : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      uriHash: isSet(object.uriHash) ? globalThis.String(object.uriHash) : "",
      admin: isSet(object.admin) ? globalThis.String(object.admin) : "",
      dexSettings: isSet(object.dexSettings)
        ? DEXSettings.fromJSON(object.dexSettings)
        : undefined,
    };
  },

  toJSON(message: EventIssued): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.issuer !== "") {
      obj.issuer = message.issuer;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.subunit !== "") {
      obj.subunit = message.subunit;
    }
    if (message.precision !== 0) {
      obj.precision = Math.round(message.precision);
    }
    if (message.initialAmount !== "") {
      obj.initialAmount = message.initialAmount;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.features?.length) {
      obj.features = message.features.map((e) => featureToJSON(e));
    }
    if (message.burnRate !== "") {
      obj.burnRate = message.burnRate;
    }
    if (message.sendCommissionRate !== "") {
      obj.sendCommissionRate = message.sendCommissionRate;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.uriHash !== "") {
      obj.uriHash = message.uriHash;
    }
    if (message.admin !== "") {
      obj.admin = message.admin;
    }
    if (message.dexSettings !== undefined) {
      obj.dexSettings = DEXSettings.toJSON(message.dexSettings);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventIssued>, I>>(base?: I): EventIssued {
    return EventIssued.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventIssued>, I>>(
    object: I
  ): EventIssued {
    const message = createBaseEventIssued();
    message.denom = object.denom ?? "";
    message.issuer = object.issuer ?? "";
    message.symbol = object.symbol ?? "";
    message.subunit = object.subunit ?? "";
    message.precision = object.precision ?? 0;
    message.initialAmount = object.initialAmount ?? "";
    message.description = object.description ?? "";
    message.features = object.features?.map((e) => e) || [];
    message.burnRate = object.burnRate ?? "";
    message.sendCommissionRate = object.sendCommissionRate ?? "";
    message.uri = object.uri ?? "";
    message.uriHash = object.uriHash ?? "";
    message.admin = object.admin ?? "";
    message.dexSettings =
      object.dexSettings !== undefined && object.dexSettings !== null
        ? DEXSettings.fromPartial(object.dexSettings)
        : undefined;
    return message;
  },
};

function createBaseEventFrozenAmountChanged(): EventFrozenAmountChanged {
  return { account: "", denom: "", previousAmount: "", currentAmount: "" };
}

export const EventFrozenAmountChanged: MessageFns<EventFrozenAmountChanged> = {
  encode(
    message: EventFrozenAmountChanged,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.account !== "") {
      writer.uint32(10).string(message.account);
    }
    if (message.denom !== "") {
      writer.uint32(18).string(message.denom);
    }
    if (message.previousAmount !== "") {
      writer.uint32(26).string(message.previousAmount);
    }
    if (message.currentAmount !== "") {
      writer.uint32(34).string(message.currentAmount);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): EventFrozenAmountChanged {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventFrozenAmountChanged();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.account = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.previousAmount = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currentAmount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventFrozenAmountChanged {
    return {
      account: isSet(object.account) ? globalThis.String(object.account) : "",
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      previousAmount: isSet(object.previousAmount)
        ? globalThis.String(object.previousAmount)
        : "",
      currentAmount: isSet(object.currentAmount)
        ? globalThis.String(object.currentAmount)
        : "",
    };
  },

  toJSON(message: EventFrozenAmountChanged): unknown {
    const obj: any = {};
    if (message.account !== "") {
      obj.account = message.account;
    }
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.previousAmount !== "") {
      obj.previousAmount = message.previousAmount;
    }
    if (message.currentAmount !== "") {
      obj.currentAmount = message.currentAmount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventFrozenAmountChanged>, I>>(
    base?: I
  ): EventFrozenAmountChanged {
    return EventFrozenAmountChanged.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventFrozenAmountChanged>, I>>(
    object: I
  ): EventFrozenAmountChanged {
    const message = createBaseEventFrozenAmountChanged();
    message.account = object.account ?? "";
    message.denom = object.denom ?? "";
    message.previousAmount = object.previousAmount ?? "";
    message.currentAmount = object.currentAmount ?? "";
    return message;
  },
};

function createBaseEventAmountClawedBack(): EventAmountClawedBack {
  return { account: "", denom: "", amount: "" };
}

export const EventAmountClawedBack: MessageFns<EventAmountClawedBack> = {
  encode(
    message: EventAmountClawedBack,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.account !== "") {
      writer.uint32(10).string(message.account);
    }
    if (message.denom !== "") {
      writer.uint32(18).string(message.denom);
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): EventAmountClawedBack {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventAmountClawedBack();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.account = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventAmountClawedBack {
    return {
      account: isSet(object.account) ? globalThis.String(object.account) : "",
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
    };
  },

  toJSON(message: EventAmountClawedBack): unknown {
    const obj: any = {};
    if (message.account !== "") {
      obj.account = message.account;
    }
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventAmountClawedBack>, I>>(
    base?: I
  ): EventAmountClawedBack {
    return EventAmountClawedBack.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventAmountClawedBack>, I>>(
    object: I
  ): EventAmountClawedBack {
    const message = createBaseEventAmountClawedBack();
    message.account = object.account ?? "";
    message.denom = object.denom ?? "";
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBaseEventWhitelistedAmountChanged(): EventWhitelistedAmountChanged {
  return { account: "", denom: "", previousAmount: "", currentAmount: "" };
}

export const EventWhitelistedAmountChanged: MessageFns<EventWhitelistedAmountChanged> =
  {
    encode(
      message: EventWhitelistedAmountChanged,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.account !== "") {
        writer.uint32(10).string(message.account);
      }
      if (message.denom !== "") {
        writer.uint32(18).string(message.denom);
      }
      if (message.previousAmount !== "") {
        writer.uint32(26).string(message.previousAmount);
      }
      if (message.currentAmount !== "") {
        writer.uint32(34).string(message.currentAmount);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): EventWhitelistedAmountChanged {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseEventWhitelistedAmountChanged();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.account = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.denom = reader.string();
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.previousAmount = reader.string();
            continue;
          }
          case 4: {
            if (tag !== 34) {
              break;
            }

            message.currentAmount = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): EventWhitelistedAmountChanged {
      return {
        account: isSet(object.account) ? globalThis.String(object.account) : "",
        denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
        previousAmount: isSet(object.previousAmount)
          ? globalThis.String(object.previousAmount)
          : "",
        currentAmount: isSet(object.currentAmount)
          ? globalThis.String(object.currentAmount)
          : "",
      };
    },

    toJSON(message: EventWhitelistedAmountChanged): unknown {
      const obj: any = {};
      if (message.account !== "") {
        obj.account = message.account;
      }
      if (message.denom !== "") {
        obj.denom = message.denom;
      }
      if (message.previousAmount !== "") {
        obj.previousAmount = message.previousAmount;
      }
      if (message.currentAmount !== "") {
        obj.currentAmount = message.currentAmount;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<EventWhitelistedAmountChanged>, I>>(
      base?: I
    ): EventWhitelistedAmountChanged {
      return EventWhitelistedAmountChanged.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<EventWhitelistedAmountChanged>, I>>(
      object: I
    ): EventWhitelistedAmountChanged {
      const message = createBaseEventWhitelistedAmountChanged();
      message.account = object.account ?? "";
      message.denom = object.denom ?? "";
      message.previousAmount = object.previousAmount ?? "";
      message.currentAmount = object.currentAmount ?? "";
      return message;
    },
  };

function createBaseEventDEXLockedAmountChanged(): EventDEXLockedAmountChanged {
  return { account: "", denom: "", previousAmount: "", currentAmount: "" };
}

export const EventDEXLockedAmountChanged: MessageFns<EventDEXLockedAmountChanged> =
  {
    encode(
      message: EventDEXLockedAmountChanged,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.account !== "") {
        writer.uint32(10).string(message.account);
      }
      if (message.denom !== "") {
        writer.uint32(18).string(message.denom);
      }
      if (message.previousAmount !== "") {
        writer.uint32(26).string(message.previousAmount);
      }
      if (message.currentAmount !== "") {
        writer.uint32(34).string(message.currentAmount);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): EventDEXLockedAmountChanged {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseEventDEXLockedAmountChanged();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.account = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.denom = reader.string();
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.previousAmount = reader.string();
            continue;
          }
          case 4: {
            if (tag !== 34) {
              break;
            }

            message.currentAmount = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): EventDEXLockedAmountChanged {
      return {
        account: isSet(object.account) ? globalThis.String(object.account) : "",
        denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
        previousAmount: isSet(object.previousAmount)
          ? globalThis.String(object.previousAmount)
          : "",
        currentAmount: isSet(object.currentAmount)
          ? globalThis.String(object.currentAmount)
          : "",
      };
    },

    toJSON(message: EventDEXLockedAmountChanged): unknown {
      const obj: any = {};
      if (message.account !== "") {
        obj.account = message.account;
      }
      if (message.denom !== "") {
        obj.denom = message.denom;
      }
      if (message.previousAmount !== "") {
        obj.previousAmount = message.previousAmount;
      }
      if (message.currentAmount !== "") {
        obj.currentAmount = message.currentAmount;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<EventDEXLockedAmountChanged>, I>>(
      base?: I
    ): EventDEXLockedAmountChanged {
      return EventDEXLockedAmountChanged.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<EventDEXLockedAmountChanged>, I>>(
      object: I
    ): EventDEXLockedAmountChanged {
      const message = createBaseEventDEXLockedAmountChanged();
      message.account = object.account ?? "";
      message.denom = object.denom ?? "";
      message.previousAmount = object.previousAmount ?? "";
      message.currentAmount = object.currentAmount ?? "";
      return message;
    },
  };

function createBaseEventDEXExpectedToReceiveAmountChanged(): EventDEXExpectedToReceiveAmountChanged {
  return { account: "", denom: "", previousAmount: "", currentAmount: "" };
}

export const EventDEXExpectedToReceiveAmountChanged: MessageFns<EventDEXExpectedToReceiveAmountChanged> =
  {
    encode(
      message: EventDEXExpectedToReceiveAmountChanged,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.account !== "") {
        writer.uint32(10).string(message.account);
      }
      if (message.denom !== "") {
        writer.uint32(18).string(message.denom);
      }
      if (message.previousAmount !== "") {
        writer.uint32(26).string(message.previousAmount);
      }
      if (message.currentAmount !== "") {
        writer.uint32(34).string(message.currentAmount);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): EventDEXExpectedToReceiveAmountChanged {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseEventDEXExpectedToReceiveAmountChanged();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.account = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.denom = reader.string();
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.previousAmount = reader.string();
            continue;
          }
          case 4: {
            if (tag !== 34) {
              break;
            }

            message.currentAmount = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): EventDEXExpectedToReceiveAmountChanged {
      return {
        account: isSet(object.account) ? globalThis.String(object.account) : "",
        denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
        previousAmount: isSet(object.previousAmount)
          ? globalThis.String(object.previousAmount)
          : "",
        currentAmount: isSet(object.currentAmount)
          ? globalThis.String(object.currentAmount)
          : "",
      };
    },

    toJSON(message: EventDEXExpectedToReceiveAmountChanged): unknown {
      const obj: any = {};
      if (message.account !== "") {
        obj.account = message.account;
      }
      if (message.denom !== "") {
        obj.denom = message.denom;
      }
      if (message.previousAmount !== "") {
        obj.previousAmount = message.previousAmount;
      }
      if (message.currentAmount !== "") {
        obj.currentAmount = message.currentAmount;
      }
      return obj;
    },

    create<
      I extends Exact<DeepPartial<EventDEXExpectedToReceiveAmountChanged>, I>
    >(base?: I): EventDEXExpectedToReceiveAmountChanged {
      return EventDEXExpectedToReceiveAmountChanged.fromPartial(
        base ?? ({} as any)
      );
    },
    fromPartial<
      I extends Exact<DeepPartial<EventDEXExpectedToReceiveAmountChanged>, I>
    >(object: I): EventDEXExpectedToReceiveAmountChanged {
      const message = createBaseEventDEXExpectedToReceiveAmountChanged();
      message.account = object.account ?? "";
      message.denom = object.denom ?? "";
      message.previousAmount = object.previousAmount ?? "";
      message.currentAmount = object.currentAmount ?? "";
      return message;
    },
  };

function createBaseEventAdminTransferred(): EventAdminTransferred {
  return { denom: "", previousAdmin: "", currentAdmin: "" };
}

export const EventAdminTransferred: MessageFns<EventAdminTransferred> = {
  encode(
    message: EventAdminTransferred,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.previousAdmin !== "") {
      writer.uint32(18).string(message.previousAdmin);
    }
    if (message.currentAdmin !== "") {
      writer.uint32(26).string(message.currentAdmin);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): EventAdminTransferred {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventAdminTransferred();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.previousAdmin = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.currentAdmin = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventAdminTransferred {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      previousAdmin: isSet(object.previousAdmin)
        ? globalThis.String(object.previousAdmin)
        : "",
      currentAdmin: isSet(object.currentAdmin)
        ? globalThis.String(object.currentAdmin)
        : "",
    };
  },

  toJSON(message: EventAdminTransferred): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.previousAdmin !== "") {
      obj.previousAdmin = message.previousAdmin;
    }
    if (message.currentAdmin !== "") {
      obj.currentAdmin = message.currentAdmin;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventAdminTransferred>, I>>(
    base?: I
  ): EventAdminTransferred {
    return EventAdminTransferred.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventAdminTransferred>, I>>(
    object: I
  ): EventAdminTransferred {
    const message = createBaseEventAdminTransferred();
    message.denom = object.denom ?? "";
    message.previousAdmin = object.previousAdmin ?? "";
    message.currentAdmin = object.currentAdmin ?? "";
    return message;
  },
};

function createBaseEventAdminCleared(): EventAdminCleared {
  return { denom: "", previousAdmin: "" };
}

export const EventAdminCleared: MessageFns<EventAdminCleared> = {
  encode(
    message: EventAdminCleared,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.previousAdmin !== "") {
      writer.uint32(18).string(message.previousAdmin);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventAdminCleared {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventAdminCleared();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.previousAdmin = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventAdminCleared {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      previousAdmin: isSet(object.previousAdmin)
        ? globalThis.String(object.previousAdmin)
        : "",
    };
  },

  toJSON(message: EventAdminCleared): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.previousAdmin !== "") {
      obj.previousAdmin = message.previousAdmin;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventAdminCleared>, I>>(
    base?: I
  ): EventAdminCleared {
    return EventAdminCleared.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventAdminCleared>, I>>(
    object: I
  ): EventAdminCleared {
    const message = createBaseEventAdminCleared();
    message.denom = object.denom ?? "";
    message.previousAdmin = object.previousAdmin ?? "";
    return message;
  },
};

function createBaseEventDEXSettingsChanged(): EventDEXSettingsChanged {
  return { previousSettings: undefined, newSettings: undefined };
}

export const EventDEXSettingsChanged: MessageFns<EventDEXSettingsChanged> = {
  encode(
    message: EventDEXSettingsChanged,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.previousSettings !== undefined) {
      DEXSettings.encode(
        message.previousSettings,
        writer.uint32(10).fork()
      ).join();
    }
    if (message.newSettings !== undefined) {
      DEXSettings.encode(message.newSettings, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): EventDEXSettingsChanged {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventDEXSettingsChanged();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.previousSettings = DEXSettings.decode(
            reader,
            reader.uint32()
          );
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newSettings = DEXSettings.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventDEXSettingsChanged {
    return {
      previousSettings: isSet(object.previousSettings)
        ? DEXSettings.fromJSON(object.previousSettings)
        : undefined,
      newSettings: isSet(object.newSettings)
        ? DEXSettings.fromJSON(object.newSettings)
        : undefined,
    };
  },

  toJSON(message: EventDEXSettingsChanged): unknown {
    const obj: any = {};
    if (message.previousSettings !== undefined) {
      obj.previousSettings = DEXSettings.toJSON(message.previousSettings);
    }
    if (message.newSettings !== undefined) {
      obj.newSettings = DEXSettings.toJSON(message.newSettings);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventDEXSettingsChanged>, I>>(
    base?: I
  ): EventDEXSettingsChanged {
    return EventDEXSettingsChanged.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventDEXSettingsChanged>, I>>(
    object: I
  ): EventDEXSettingsChanged {
    const message = createBaseEventDEXSettingsChanged();
    message.previousSettings =
      object.previousSettings !== undefined && object.previousSettings !== null
        ? DEXSettings.fromPartial(object.previousSettings)
        : undefined;
    message.newSettings =
      object.newSettings !== undefined && object.newSettings !== null
        ? DEXSettings.fromPartial(object.newSettings)
        : undefined;
    return message;
  },
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
  ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U>
  ? ReadonlyArray<DeepPartial<U>>
  : T extends {}
  ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
